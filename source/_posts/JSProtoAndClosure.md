---
title: 《深入理解Javascript原型和闭包》笔记
date: 2016-08-14 16:02:52
categories:
- Javascript
tags:
- prototype
- closure
---

作为一个前j2ee方向的javaer，当时对于前端、对于JS只是粗浅的认识。
昨晚在整理印象笔记的时候，恰巧看到“学习方向”分支下的前端篇，正好现在也在从事前端工作，由于之前对原型和闭包理解不是很深刻。
所以，有了这个学习笔记。笔记不适合阅读，请移步参考资料。此文放出来，只是取悦自己，记录成长，加深印象。
现在，还不是时候，依然在沉淀知识中。后续会像这些网上的大牛一样，消费自己，取悦读者。

<!-- more -->

## 一切都是对象

js里面的类型分为值类型和引用类型，值类型没有对象的概念。

类型判断 typeof()
对象判断 xx instanceof x

一切（引用类型）都是对象，对象是属性的集合。

## 函数和对象的关系

对象都是通过函数来创建的
var obj = new Object();

typeof(Object) 的值为function

## prototype原型

默认给函数一个属性-prototype

prototype的属性值是一个对象，该对象有一个constructor属性，其属性值指向函数本身

每个对象都有一个隐藏的__proto__属性，指向创建该对象的函数的prototype(即fn.__proto__ === Fn.prototype)

## 隐式原型

```
函数有prototype属性
prototype属性值是一个对象
上述对象中有个constructor属性
constructor属性值指向的是函数本身
另外，对象有__proto__属性，被称为隐式原型
__proto__属性指向创建该对象的函数的prototype
自定义函数的prototype对象的__proto__属性指向Object.prototype
Object.prototype没有__proto__属性
函数也是对象，即函数也有__proto__属性
函数的__proto__属性指向Function.prototype
Function.__proto__属性指向Function.prototype,即Function是被自身创建的
Function.prototype对象的__proto__属性指向Object.prototye
```

## instanceof

Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。

Instanceof的判断队则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。

instanceof表示的就是一种继承关系，或者原型链的结构。

## 继承

javascript的继承是通过原型链来体现的。

访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。

在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？
Object.prototype中的hasOwnProperty方法

## 原型的灵活性

在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。
而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。

首先，对象属性可以随时改动。
对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。

## 执行上下文

在“准备工作”中完成了哪些工作：
变量、函数表达式——变量声明，默认赋值为undefined；
this——赋值；
函数声明——赋值；
这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。

javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。

![](http://ldc4.qiniudn.com/images/JSProtoAndClosure/JSProtoAndClosure-1.png)

## this

在函数中this到底取何值?
是在函数真正被调用执行的时候确定的，函数定义的时候确定不了

1.构造函数
this表示构造出来的对象
如果是当成普通函数执行，则表示window
2.函数作为对象的一个属性
并且的确是作为对象的一个属性被调用，this表示该对象
3.函数用call或apply调用时
this表示传入的对象
4.全局&调用普通函数
this都表示window

## 执行上下文栈

这个很好理解。

## 作用域

javascript没有块级作用域
javascript除了全局作用域之外，只有函数可以创建作用域。

所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

## 作用域与上下文环境

除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定

## 自由变量

在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。

（要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”）  ——其实这就是所谓的“静态作用域”。

## 作用域链

第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；

第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；

第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；

第四步，跳转到第一步。

## 闭包

1.函数作为返回值
2.函数作为参数

使用闭包会增加内容开销


## 写在最后
工作之余，切不可忘记充电

参考资料：
http://www.cnblogs.com/wangfupeng1988/p/3977924.html
