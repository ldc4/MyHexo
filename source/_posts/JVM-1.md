title: JVM之类文件结构
date: 2016-04-12 14:43:31
categories:
- JVM
tags:
- jvm
- class
- 字节码文件
- 字节码指令
---

实现“无关性”的基石：虚拟机和字节码存储格式


<!--more-->

# 字节码文件
class文件是一组以8位字节为基础单位的二进制流。
当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储

Class文件格式采用一种类似于C语言结构体的伪结构（无符号数和表）来存储数据

无符号数：属于基本的数据类型
     以 u1、u2、u4、u8来代表1 2 4 8 字节的无符号数
    
表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾
     用于描述有层次关系的复合结构的数据

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的格式

class文件中字节序为Big-Endian

整个class文件本质上就是一张表

---

## 魔数与Class文件的版本
每个Class文件的头4个字节称为魔数：用于确定这个文件是否为一个能被虚拟机接受的Class文件
0xCAFEBABE
5 6 字节 为次版本号
7 8 字节 为主版本号

## 常量池
紧跟着主次版本号之后的是常量池入口
常量词可以理解为Class文件之中的资源仓库


由于常量池中常量的数量是不固定的，所以在常量池的入口放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）
这个容量计数是从1而不是从0开始的

常量池中主要存放两大类常量：
     字面量：
          文本字符串、申明为final的常量值
     符号引用：
          类和接口的全限定名
          字段的名称和描述符
          方法的名称和描述符
    
当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

常量池中每一项常量都是一个表

Java程序中如果定义了超过64K长度的方法名或字段名，将无法编译

javap:用于分析class文件字节码的工具
    
     javap -verbose Helloworld


## 访问标志

用于识别一些类或者接口层次的访问信息

- 这个Class是类还是接口
- 是否定义为public类型
- 是否定义为abstract类型
- 如果是类的话，是否被声明为final
等

0x0001 ACC_PUBLIC
0x0010 ACC_FINAL
0x0020 ACC_SUPER
0x0200 ACC_INTERFACE
0x0400 ACC_ABSTRACT
0x1000 ACC_SYNTHETIC
0x2000 ACC_ANNOTATION
0x4000 ACC_ENUM

## 类索引、父类索引与接口索引集合
Class文件由这三项数据来确定这个类的继承关系。

类索引和父类索引 为u2类型的数据
接口索引集合是一组u2类型的数据的集合：第一项为接口计数器（interface_count）


## 字段表集合
- 字段的作用域（public、private、protected修饰符）
- 是实例变量还是类变量（static修饰符）
- 可变性（final）
- 并发可见性（volatile修饰符，是否强制从主内存读写）
- 可否被序列化（transient修饰符）
- 字段数据类型（基本类型，对象，数组）
- 字段名称

u2  access_flags
u2  name_index
u2  descriptor_index
字段和方法的描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。
u2  attributes_count
attribute_info  attributes


字段表集合中不会列出从超类或者父类口中继承而来的字段，但有可能列出原本java代码中不存在的字段，
譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的修饰符不一致，那字段重名就是合法的。


## 方法表集合

和字段表集合大同小异。

方法里的java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为”Code“的属性里面

## 属性表集合

（略）。。。太复杂了！



# 字节码指令

java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。

jvm采用面向操作数栈

大多数的指令都包含了其操作所对应的数据类型信息。

a代表reference

指令集故意被设计成非完全独立的
Not Orthogonal

大多数指令没有支持byte,char,short
没有任何指令支持boolean...

编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据

阅读字节码

## 加载和存储指令

回顾：java虚拟机栈，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，有如下：
-将一个局部变量加载到操作数：`iload,iload_<n>,lload,lload_<n>,fload,fload_<n>,dload,dload_<n>,aload,aload_<n>`
-将一个数值从操作数栈存储到局部变量表：`Tstore,Tstore_<n>`
-将一个常量加载到操作数栈
-扩充局部变量表的访问索引的指令：wide

`iload_<n> `代表了 iload_0 iload_1 iload_2和iload_3

例如iload_0的语义与操作数为0的iload指令语义完全一致。

## 运算指令
运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

大体上算术指令可以分为两种：
-对整型数据进行运算的指令
-对浮点型数据进行运算的指令

加法指令：Tadd
减法指令：Tsub
乘法指令：Tmul
除法指令：Tdiv
求余指令：Trem
取反指令：Tneg
位移指令：Tshl,Tshr,Tushr
按位或指令：Tor
按位与指令：Tand
按位异或指令：Txor
局部变量自增指令：iinc
比较指令：Tcmpg,Tcmpl,Tcmp

## 类型转换指令

类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作
或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

jvm直接支持宽化类型转换（小范围类型向大范围类型的安全转换）
处理窄化类型转换，必须显示使用转换指令来完成，指令为T2T
i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f
窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况。

## 对象创建与访问指令

创建类实例的指令： new
创建数组的指令：newarray,anewarray,multianewarray
访问类字段和实例字段的指令：getfield,putfield,getstatic,putstatic
把一个数组元素加载到操作数栈的指令：Taload
将一个操作数栈的值存储到数组元素中的指令：Tastore
取数组长度的指令：arraylength
检查类实例类型的指令：instanceof,checkcast

## 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令

将操作数栈的栈顶一个或两个元素出栈：pop,pop2
复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2
将栈最顶端的两个数值互换：swap

## 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令（而不是控制转移指令）的下一条指令继续执行程序、

从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值

条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne
符合条件分支：tableswitch,lookupswitch
无条件分支：goto,goto_w,jsr,jsr_w,ret(jump and set return)

对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg,dcmpl,fcmpg,fcmpl,lcmp）,运算指令会返回一个整数型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。

## 方法调用和返回指令

invokevirtual：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）
invokeinterface：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出合适的方法进行调用
invokespecial：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
invokestatic：用于调用类方法
invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法

前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分配逻辑是有用户所设定的引导方法决定的。

Treturn
return指令供声明为void的方法，实例初始化方法以及类和接口的类初始化方法使用。

## 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现。
处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。

## 同步指令

JVM支持方法级同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。

方法级同步是隐式的，无须字节码指令来控制，它是实现在方法调用和返回操作之中。ACC_SYNCHRONIZED访问标志
同步一段指令集序列：monitorenter和monitorexit指令来支持synchronized关键字

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorrenter指令都必须执行其对应的monitorexit指令,而无论这个方法是正常结束还是异常结束。

---

# 书中总结

前方高能！！！

公有设计与私有实现：

Class文件格式以及字节码指令集，这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的

虚拟机实现的主要方式有：
将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集
将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集

Class文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。







