title: HeadFirst设计模式简记
date: 2016-05-20 13:22:13
categories:
- DesignPattern
tags:
- designpattern
---
久闻GOF大名，但是我还是打算先从《HeadFirst设计模式》看着走。
同样，该文依然是作为巩固记忆的学习总结，不适合当做学习资料阅读。

<!--more-->

## 策略模式

设计原则：
1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起
2. 针对接口编程，而不是针对实现编程
3. 多用组合，少用继承

策略模式：
定义算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户

我的理解：
策略模式就是利用了多态的特性。

比如spring的xml与properties资源加载，就算是一个策略模式

![strategy](http://ldc4.qiniudn.com/images/HeadFirst/strategy.png)

## 观察者模式

出版者+订阅者=观察者模式

Subject 与 Observer

观察者模式：
定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

松耦合：观察者模式提供了一种对象设计，让主题和观察者之间松耦合
主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起许多对象控制同一份数据来，可以得到更干净的OO设计

设计原则：
为了交互对象之间的松耦合设计而努力

松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降低到了最底

（天气系统设计）

Java内置的观察者模式（Observable/Observer）

观察者模式有两种获取数据的方式：**推** 和 **拉**

拉的话，被观察者就不用发送数据了，直接通知一下，我改变了，然后观察者就调用被观察者的getter方法来获得数据。

JDK的内置的观察者模式的Observable是个类，这种设计是在面向现实编程了，而且通知观察者的顺序是从后往前的。

![observer](http://ldc4.qiniudn.com/images/HeadFirst/observer.jpg)

## 装饰者模式

设计原则：
类应该对扩张开放，对修改关闭。（开闭原则）

把注意力集中在设计中最有可能改变的地方，然后应用开闭原则

**装饰者和被装饰对象有相同的超类型**

装饰者模式：
动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

缺点：会产生很多小类

java i/o系统就是典型的装饰者模式

这里需要思考一个混淆性问题：装饰、包装、代理？

![decorator](http://ldc4.qiniudn.com/images/HeadFirst/decorator.png)

## 工厂模式

简单工厂，仅仅把new部分抽取出来单独封装了起来。但是当有新的具体的实现类，还是得去修改这个简单工厂

简单工厂只是一种习惯，并不是真正意义上的模式

工厂方法模式：
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

设计原则：
要依赖抽象，不要依赖具体实现（依赖倒置原则）
(不能让高层组件依赖低层组件，而且，不管高层或低层组件，”两者“都应该依赖于抽象)

抽象工厂模式：
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

抽象工厂的方法经常以工厂方法的方式实现

工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象
抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中


## 单例模式

经典实现：（懒汉模式）
```
private static Singleton singleton;

private Singleton(){
}

public Singleton getInstance(){
     if(singleton==null){
          singleton = new Singleton();
     }
     return singleton;
}
```
单例模式：
确保一个类只有一个实例，并提供一个全局访问点

多线程环境下，经典实现不能正常工作

饿汉模式，JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。

双重校验锁：
```
private volatile static Singleton singleton;

private Singleton(){}

public static Singleton getInstance(){
     if(singleton==null){
          sysnchronized(Singleton.class){
               if(singleton==null){
                    singleton = new Singleton();
               }
          }
     }
     return singleton;
}
```

如果使用JVM 1.2或之前的版本，你必须建立单例注册表，以免垃圾收集器将单例回收了。

## 命令模式

餐厅：顾客->订单->女服务员->订单->厨师

client、command、invoker、receiver

简单命令模式

命令模式：
将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

我们知道一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。

空对象，有时候空对象本身也被视为是一种设计模式。

撤销，undo，使用状态来撤销

宏命令

队列请求，日志请求（即命令也可以用来实现日志和事务系统）

![command](http://ldc4.qiniudn.com/images/HeadFirst/command.png)

## 适配器模式和外观模式

适配器模式：
将一个类的接口，转换成客户期望的另外一个接口。适配器让原本接口不兼容的类可以合作无间。

对象适配器和类适配器

类适配器需要多重继承，java并不支持

适配器与装饰者的区别

装饰者的目的：不改变接口，但加入职责
适配器的目的：将一个接口转成另一个接口
外观的目的：让接口更简单

![adapter](http://ldc4.qiniudn.com/images/HeadFirst/adapter.png)

外观模式：
提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

我的理解：
其实，这就是最直接的组合解耦的表现！

设计原则：
最少知识原则：只和你的密友谈话。

这个原则提供的方针：
就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：
1.该对象本身
2.被当做方法的参数而传递进来的对象
3.此方法所创建或实例化的任何对象
4.对象的任何组件

![facade](http://ldc4.qiniudn.com/images/HeadFirst/facade.png)

## 模板方法模式

模板方法模式：
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。
模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

这模式其实就是利用继承抽象基类。基类就是所谓的模板。

hook方法：是一种被声明在抽象类中的方法，但只有空的或者默认的实现。

好莱坞原则？：
别调用（打电话给）我们，我们会调用（打电话给）你。

避免让高层和底层组件之间有明显的环状依赖。

模板方法：子类决定如何实现算法中的步骤
策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为
工厂方法：由子类决定实例化哪个具体类

为了防止子类改变模板方法中的算法，可以将模板方法声明为final。

策略模式和模板方法模式都封装算法，一个用组合，一个用继承。
工厂方法是模板方法的一种特殊版本。

![template](http://ldc4.qiniudn.com/images/HeadFirst/template.png)

## 迭代器与组合模式

迭代器模式：
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

单一责任

设计原则：
一个类应该只有一个引起变化的原因

内聚

![iterator](http://ldc4.qiniudn.com/images/HeadFirst/iterator.png)

组合模式：
允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户一致的方式处理个别对象以及对象组合

迭代器 -提供一个方式来遍历集合，而无须暴露集合的实现
组合 -客户可以将对象的集合以及个别的对象一视同仁

在实现组合模式时，有许多设计上的折衷。根据需要来平衡透明性和安全性。

![composite](http://ldc4.qiniudn.com/images/HeadFirst/composite.png)